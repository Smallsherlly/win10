一.错误处理
	1.函数返回值表示错误
		合法返回值表示成功，非法返回值表示失败
		正常指针表示成功，空指针表示失败
		返回值 true 表示成功，返回 false 表示失败
		返回值为0表示成功，返回值为-1表示失败
		函数执行永远成功 printf
	2.使用errno来表示错误
		#include <errno.h>
		errno 是一个全局变量，它是一个整数，代表错误编码
		使用strerror将errno转换成有意义的字符串 <string.h>
		成功时不会修改上次错误的编码，只能用来查看错误信息
		errno 是一个全局变量，他的值随时可能被修改
		perror 打印错误信息
		printf("%m");打印错误信息
二.环境变量
	1.每个程序卡死运行后就会收到一张环境变量表
	是一个以NULL结尾的字符指针数组
	2.全局变量(char**)获取environ 也可以使用main函数参数来获取
	3.环境变量的 增 删 改 查
		getenv //获取环境变量的参数
		putenv //设置环境变量 name=参数
		setenv //设置环境变量 name，参数，设置方式
		unsetenv //删除环境变量
		clearenv //清空环境变量

三.内存管理
	用户层：
		STL JAVA 自动分配/释放
		C++		 new/delete
		标准C	 malloc/calloc/realloc/free
		POSIX C  brk/sbrk
		Linux C  mmap/munmap
	系统层：
		kernel(内核) kmalloc/vmalloc
		driver		 get_set_page
四.进程映像
	程序：保存在硬盘上的可执行文件
	进程：加载到内存后，正在执行的程序
	进程映像：程序在内存中的分布
	进程在内存中的布局从低到高依次是：
		代码段：函数 字面值 常量
		数据区：初始化过的全局变量  初始化过的静态变量
		bss区 ：未初始化过的全局变量 未初始化过的静态变量
		堆区  ：malloc calloc realloc 
		栈区  ：变量
		命令行参数和环境变量：argv environ
		const是为变量增加了一层保护
	/proc/进程号/maps 内存分布记录在此文件中
		getpid();获取进程号
		size可以计算出程序要使用的代码区+数据区+bss区一共使用多少字节

五.虚拟内存
	1.每个程序都会拥有 4G 虚拟内存空间(32位系统)
	2.普通用户永远不能直接访问物理内存
	3.虚拟内存使用前要与物理内存进行映射(只能由操作系统来完成)
	4.更大更安全
	5.4个G的虚拟内存分为两个部分
	  0  3 用户
	  3  4 内核使用
	6.用户不能访问内核，但可以使用系统接口(进入内核态)
	7.内存越界
		段错误 正常使用 后续错误 不稳定 段错误
	8.每个进程的虚拟内存相互独立，进程之间交换地址没有意义
	9.malloc 初次使用会映射33页(一页4k)
		malloc的内存管理使用一个双向链表在维护
		不能干扰双向链表的节点
	10.进程结束后，所有的虚拟内存会被释放掉
六.内存管理api
	POSIX 标准 brk sbkr
	这两个函数都能单独地进行内存的申请和释放
	但一般两个函数会配合使用

	void* sbrk(int flag);
		flag
		==0	返回末尾断点          
		 >0 分配内存，返回上次末尾断点
		 <0 释放内存
	int brk(void* end);
		设置末尾断点地址
		成功返回0，失败返回-1

	mmap/munmap
		分配内存 
		共享内存 
		共享文件

作业：
	1.计算出［1000，10000］素数，存储内存中，尽量不浪费内存
	2.使用brk/sbrk完成基于顺序表的栈和队列
	不允许使用标准C的内存管理函数
